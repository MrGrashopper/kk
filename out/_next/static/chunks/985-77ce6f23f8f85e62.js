"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[985],{4207:function(e,t){function NoopHead(){return null}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return NoopHead}}),("function"==typeof t.default||"object"==typeof t.default&&null!==t.default)&&void 0===t.default.__esModule&&(Object.defineProperty(t.default,"__esModule",{value:!0}),Object.assign(t.default,t),e.exports=t.default)},2261:function(e,t,n){n.d(t,{QS:function(){return useSwipeable}});var o=n(2265);let r={delta:10,preventScrollOnSwipe:!1,rotationAngle:0,trackMouse:!1,trackTouch:!0,swipeDuration:1/0,touchEventOptions:{passive:!0}},i={first:!0,initial:[0,0],start:0,swiping:!1,xy:[0,0]},s="mousemove",a="mouseup";function rotateXYByAngle(e,t){if(0===t)return e;let n=Math.PI/180*t,o=e[0]*Math.cos(n)+e[1]*Math.sin(n),r=e[1]*Math.cos(n)-e[0]*Math.sin(n);return[o,r]}function useSwipeable(e){var t,n,c;let u;let{trackMouse:l}=e,p=o.useRef(Object.assign({},i)),d=o.useRef(Object.assign({},r)),h=o.useRef(Object.assign({},d.current));for(u in h.current=Object.assign({},d.current),d.current=Object.assign(Object.assign({},r),e),r)void 0===d.current[u]&&(d.current[u]=r[u]);let[f,g]=o.useMemo(()=>(function(e,t){let onStart=t=>{let n="touches"in t;n&&t.touches.length>1||e((e,o)=>{o.trackMouse&&!n&&(document.addEventListener(s,onMove),document.addEventListener(a,onUp));let{clientX:r,clientY:c}=n?t.touches[0]:t,u=rotateXYByAngle([r,c],o.rotationAngle);return o.onTouchStartOrOnMouseDown&&o.onTouchStartOrOnMouseDown({event:t}),Object.assign(Object.assign(Object.assign({},e),i),{initial:u.slice(),xy:u,start:t.timeStamp||0})})},onMove=t=>{e((e,n)=>{let o="touches"in t;if(o&&t.touches.length>1)return e;if(t.timeStamp-e.start>n.swipeDuration)return e.swiping?Object.assign(Object.assign({},e),{swiping:!1}):e;let{clientX:i,clientY:s}=o?t.touches[0]:t,[a,c]=rotateXYByAngle([i,s],n.rotationAngle),u=a-e.xy[0],l=c-e.xy[1],p=Math.abs(u),d=Math.abs(l),h=(t.timeStamp||0)-e.start,f=Math.sqrt(p*p+d*d)/(h||1),g=[u/(h||1),l/(h||1)],v=p>d?u>0?"Right":"Left":l>0?"Down":"Up",b="number"==typeof n.delta?n.delta:n.delta[v.toLowerCase()]||r.delta;if(p<b&&d<b&&!e.swiping)return e;let O={absX:p,absY:d,deltaX:u,deltaY:l,dir:v,event:t,first:e.first,initial:e.initial,velocity:f,vxvy:g};O.first&&n.onSwipeStart&&n.onSwipeStart(O),n.onSwiping&&n.onSwiping(O);let w=!1;return(n.onSwiping||n.onSwiped||n[`onSwiped${v}`])&&(w=!0),w&&n.preventScrollOnSwipe&&n.trackTouch&&t.cancelable&&t.preventDefault(),Object.assign(Object.assign({},e),{first:!1,eventData:O,swiping:!0})})},onEnd=t=>{e((e,n)=>{let o;if(e.swiping&&e.eventData){if(t.timeStamp-e.start<n.swipeDuration){o=Object.assign(Object.assign({},e.eventData),{event:t}),n.onSwiped&&n.onSwiped(o);let r=n[`onSwiped${o.dir}`];r&&r(o)}}else n.onTap&&n.onTap({event:t});return n.onTouchEndOrOnMouseUp&&n.onTouchEndOrOnMouseUp({event:t}),Object.assign(Object.assign(Object.assign({},e),i),{eventData:o})})},cleanUpMouse=()=>{document.removeEventListener(s,onMove),document.removeEventListener(a,onUp)},onUp=e=>{cleanUpMouse(),onEnd(e)},attachTouch=(e,t)=>{let cleanup=()=>{};if(e&&e.addEventListener){let n=Object.assign(Object.assign({},r.touchEventOptions),t.touchEventOptions),o=[["touchstart",onStart,n],["touchmove",onMove,Object.assign(Object.assign({},n),t.preventScrollOnSwipe?{passive:!1}:{})],["touchend",onEnd,n]];o.forEach(([t,n,o])=>e.addEventListener(t,n,o)),cleanup=()=>o.forEach(([t,n])=>e.removeEventListener(t,n))}return cleanup},n={ref:t=>{null!==t&&e((e,n)=>{if(e.el===t)return e;let o={};return e.el&&e.el!==t&&e.cleanUpTouch&&(e.cleanUpTouch(),o.cleanUpTouch=void 0),n.trackTouch&&t&&(o.cleanUpTouch=attachTouch(t,n)),Object.assign(Object.assign(Object.assign({},e),{el:t}),o)})}};return t.trackMouse&&(n.onMouseDown=onStart),[n,attachTouch]})(e=>p.current=e(p.current,d.current),{trackMouse:l}),[l]);return p.current=(t=p.current,n=d.current,c=h.current,n.trackTouch&&t.el?t.cleanUpTouch?n.preventScrollOnSwipe!==c.preventScrollOnSwipe||n.touchEventOptions.passive!==c.touchEventOptions.passive?(t.cleanUpTouch(),Object.assign(Object.assign({},t),{cleanUpTouch:g(t.el,n)})):t:Object.assign(Object.assign({},t),{cleanUpTouch:g(t.el,n)}):(t.cleanUpTouch&&t.cleanUpTouch(),Object.assign(Object.assign({},t),{cleanUpTouch:void 0}))),f}},7712:function(e,t,n){n.d(t,{_:function(){return useAnimation}});var o=n(6567),r=n(7798),i=n(9870);function animationControls(){let e=!1,t=new Set,n={subscribe:e=>(t.add(e),()=>void t.delete(e)),start(n,r){(0,o.k)(e,"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");let s=[];return t.forEach(e=>{s.push((0,i.d)(e,n,{transitionOverride:r}))}),Promise.all(s)},set:n=>((0,o.k)(e,"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."),t.forEach(e=>{(0,r.gg)(e,n)})),stop(){t.forEach(e=>{!function(e){e.values.forEach(e=>e.stop())}(e)})},mount:()=>(e=!0,()=>{e=!1,n.stop()})};return n}var s=n(961),a=n(538);let useAnimation=function(){let e=(0,s.h)(animationControls);return(0,a.L)(e.mount,[]),e}},4327:function(e,t,n){n.d(t,{YD:function(){return useInView}});var o=n(2265),r=Object.defineProperty,i=new Map,s=new WeakMap,a=0,c=void 0;function useInView({threshold:e,delay:t,trackVisibility:n,rootMargin:r,root:u,triggerOnce:l,skip:p,initialInView:d,fallbackInView:h,onChange:f}={}){var g;let[v,b]=o.useState(null),O=o.useRef(),[w,S]=o.useState({inView:!!d,entry:void 0});O.current=f,o.useEffect(()=>{let o;if(!p&&v)return o=function(e,t,n={},o=c){if(void 0===window.IntersectionObserver&&void 0!==o){let r=e.getBoundingClientRect();return t(o,{isIntersecting:o,target:e,intersectionRatio:"number"==typeof n.threshold?n.threshold:0,time:0,boundingClientRect:r,intersectionRect:r,rootBounds:r}),()=>{}}let{id:r,observer:u,elements:l}=function(e){let t=Object.keys(e).sort().filter(t=>void 0!==e[t]).map(t=>{var n;return`${t}_${"root"===t?(n=e.root)?(s.has(n)||(a+=1,s.set(n,a.toString())),s.get(n)):"0":e[t]}`}).toString(),n=i.get(t);if(!n){let o;let r=new Map,s=new IntersectionObserver(t=>{t.forEach(t=>{var n;let i=t.isIntersecting&&o.some(e=>t.intersectionRatio>=e);e.trackVisibility&&void 0===t.isVisible&&(t.isVisible=i),null==(n=r.get(t.target))||n.forEach(e=>{e(i,t)})})},e);o=s.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:s,elements:r},i.set(t,n)}return n}(n),p=l.get(e)||[];return l.has(e)||l.set(e,p),p.push(t),u.observe(e),function(){p.splice(p.indexOf(t),1),0===p.length&&(l.delete(e),u.unobserve(e)),0===l.size&&(u.disconnect(),i.delete(r))}}(v,(e,t)=>{S({inView:e,entry:t}),O.current&&O.current(e,t),t.isIntersecting&&l&&o&&(o(),o=void 0)},{root:u,rootMargin:r,threshold:e,trackVisibility:n,delay:t},h),()=>{o&&o()}},[Array.isArray(e)?e.toString():e,v,u,r,l,p,n,h,t]);let j=null==(g=w.entry)?void 0:g.target,m=o.useRef();v||!j||l||p||m.current===j||(m.current=j,S({inView:!!d,entry:void 0}));let E=[b,w.inView,w.entry];return E.ref=E[0],E.inView=E[1],E.entry=E[2],E}o.Component}}]);